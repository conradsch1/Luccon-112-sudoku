from cmu_graphics import *
import math
import os
import random
import copy

######
#make Allregions list
#####
def createAllRegions(rows, cols):
    rowRegions = createAllRowsRegions(rows, cols)
    colRegions = createAllColRegions(rows, cols)
    blockRegions = createAllBlockRegions(rows)
    return [rowRegions, colRegions, blockRegions]

def createAllRowsRegions(rows, cols):
    rowRegions = []
    for row in range(rows):
        rowList = [(row, col) for col in range(cols)]
        rowRegions.append(rowList)
    return rowRegions

def createAllColRegions(rows, cols):
    colRegions = []
    for col in range(cols):
        colList = [(row, col) for row in range(rows)]
        colRegions.append(colList)
    return colRegions

#used isLegal sedoku code
def createAllBlockRegions(rows):
    blockRegions = []
    numberOfBlocks = rows
    blockSize = pythonRound((rows) ** 0.5)
    for block in range(numberOfBlocks):
        blockList = createBlockList(block, blockSize)
        blockRegions.append(blockList)
    return blockRegions
        
def createBlockList(block, blockSize):
    startingRow = block // blockSize * blockSize
    startingCol = block % blockSize * blockSize
    blockList = []
    for drow in range(blockSize):
        for dcol in range(blockSize):
            (row, col) = startingRow + drow, startingCol + dcol
            blockList.append((row,col))
    return blockList

#global variabe list of All regions [rowRegions, ColRegions, BlockRegions]
regions = createAllRegions(9, 9)

######
######

#make intial legals when make intial board and unchanged legals. Then add make new until have intial board. then clear state list

class State():
    def __init__(self, board, legals):
        self.board = board
        self.legals = legals

    @staticmethod
    def getRowRegion(row):
        return regions[0][row]

    @staticmethod
    def getColRegion(col):
        return regions[1][col]

    @staticmethod
    def getBlockRegion(block):
        return regions[2][block]

    @staticmethod
    def getBlock(row, col):
        rows = len(regions[0][0])
        blockSize = pythonRound((rows) ** 0.5)
        return ((row // blockSize)) * blockSize + (col//blockSize)

    @staticmethod
    def getCellRegions(row, col):
        rowRegion = State.getRowRegion(row)
        colRegion = State.getColRegion(col)
        block = State.getBlock(row, col)
        blockRegion = State.getBlockRegion(block)
        return (rowRegion, colRegion, blockRegion)


    def banLegals(self, row, col, value):
        cellRegions = State.getCellRegions(row, col)
    
    def set(self, row, col, value):
        nextState = copy.deepcopy(self)
        nextState.board[row][col] = value
        banLegals(self, row, col, value)
        




#################

    def getRowRegion(self, row):
        rows, cols = len(self.board), len(self.board[0])
        
    def getCellRegions(self, row, col):
        rowRegion = getRowRegion(self, row)
        colregion = getColRegion(self, col)
        blockRegion = getBlockRegion(self, row, col)

def rowRegion(board):
    rows, cols = len(board), len(board[0])
    rowList = []
    eachRow = []
    for row in range(rows):
        for col in range(cols):
            eachRow.append((row, col))
        rowList.append(eachRow)
        eachRow = []
        print(rowList)

def colRegion(board):
    rows, cols = len(board), len(board[0])
    colList = []
    eachCol = []
    for col in range(cols):
        for row in range(rows):
            eachCol.append((row, col))
        colList.append(eachCol)
        eachCol = []

def blockRegion(board):
    rows, cols = len(board), len(board[0])
    

class State:
    def __init__(self, board, legals, row, col, block):
        self.board = board
        self.legals = legals
        self.row = row
        self.col = col
        self.block = block

    def getRowRegion(self, row):
        rows, cols = len(self.board), len(self.board[0])
        for i in range(rows):
            if i == self.row:
                return i

    def getColRegion(self, col):
        rows, cols = len(self.board), len(self.board[0])
        for i in range(rows):
            for j in range(cols):
                if j == self.col:
                    return j

    def getBlock(self, row, col):
        rows, cols = len(self.board), len(self.board[0])
        rowIndex = None
        colIndex = None
        for i in range(rows):
            for j in range(cols):
                if i == self.row and j == self.col:
                    rowIndex = i
                    colIndex = j
    

        



##################
# play screen
###################

def play_onScreenStart(app):
    app.rows = 9
    app.cols = 9
    app.boardLeft = 50
    app.boardTop = 50
    app.boardWidth = 300
    app.boardHeight = 300
    app.boxWidth = app.boardWidth/app.cols
    app.boxHeight = app.boardHeight/app.rows
    app.board = []
    app.intialBoard = None

    app.cellBorderWidth = 1

    app.selection = None
    app.number = None
    difficulty = app.getTextInput('''What difficulty do you want? Options:
                                     easy, medium, hard, expert, evil''')
    if difficulty == '': 
        difficulty = None
    boardPath = play_loadRandomBoard(difficulty)
    print(boardPath)
    play_intializeBoard(app, boardPath)

def play_readFile(path):
    with open(path, "rt") as f:
        return f.read()

def play_intializeBoard(app, boardPath):
    contents = play_readFile(boardPath)
    for line in contents.splitlines():
        rowList = []
        for cell in line.split(' '):
            rowList.append(cell)
        app.board.append(rowList)
    app.intialBoard = app.board

def play_onMousePress(app, mouseX, mouseY):
    app.selection = None
    cell = play_getCell(app, mouseX, mouseY)
    if cell != None:
        row, col = cell
        app.number = cell
            
def play_onMouseMove(app, mouseX, mouseY):
    selectedCell = play_getCell(app, mouseX, mouseY)
    if selectedCell == None:
        app.selection = None
    else:
        row, col = selectedCell
        app.selection = selectedCell
    
def play_onKeyPress(app, key):
    if app.number != None:
        row, col = app.number
        if key.isdigit():
            app.board[row][col] = key
    #add to dirrections
    elif key == 'h':
        setActiveScreen('help')
    elif key == 's':
        setActiveScreen('splash')
            
def play_redrawAll(app):
    play_drawBoard(app)
    play_drawBoardBorder(app)
    play_drawLines(app)
    
def play_drawBoard(app):
    for row in range(app.rows):
        for col in range(app.cols):
            play_drawCell(app, row, col)
            if app.board[row][col] != None:
                drawLabel(app.board[row][col], 
                            app.boardLeft + (app.boxWidth*col)+app.boxWidth/2, 
                            app.boardTop + (app.boxHeight*row)+app.boxHeight/2,
                                size = 16)
            
def play_drawBoardBorder(app):
    drawRect(app.boardLeft, app.boardTop, app.boardWidth, app.boardHeight,
            fill = None, border = 'black', 
            borderWidth = 4 * app.cellBorderWidth)

#####
# printing debugging   
####
def repr2dList(L):
    if (L == []): return '[]'
    output = [ ]
    rows = len(L)
    cols = max([len(L[row]) for row in range(rows)])
    M = [['']*cols for row in range(rows)]
    for row in range(rows):
        for col in range(len(L[row])):
            M[row][col] = repr(L[row][col])
    colWidths = [0] * cols
    for col in range(cols):
        colWidths[col] = max([len(M[row][col]) for row in range(rows)])
    output.append('[\n')
    for row in range(rows):
        output.append(' [ ')
        for col in range(cols):
            if (col > 0):
                output.append(', ' if col < len(L[row]) else '  ')
            output.append(M[row][col].rjust(colWidths[col]))
        output.append((' ],' if row < rows-1 else ' ]') + '\n')
    output.append(']')
    return ''.join(output)

def print2dList(L):
    print(repr2dList(L))
            
def play_drawCell(app, row, col):
    cellLeft, cellTop = play_getCellLeftTop(app, row, col)
    cellWidth, cellHeight = play_getCellSize(app)
    #print2dList(app.initialBoard)
    if app.intialBoard[row][col] != '0':
        color = 'mistyRose'
    else:
        color = None
    if (row, col) == app.selection:
        color = 'pink'
    elif (row, col) == app.number:
        color = 'red'
    
    drawRect(cellLeft, cellTop, cellWidth, cellHeight,
            fill = color, border = 'black',
            borderWidth = app.cellBorderWidth)
            
def play_drawLines(app):
    #draw horizontal lines
    for i in range(len(app.board)):
        if (i+1) % 3 == 0 and i != 8:
            drawLine(app.boardLeft, app.boardTop + (i+1) * app.boxWidth, 
                        app.boardLeft + app.boardWidth,
                        app.boardTop + (i+1) * app.boxWidth,
                        lineWidth = 4 * app.cellBorderWidth)
    #draw vertical lines
    for j in range(len(app.board[0])):
        if (j+1) % 3 == 0 and j != 8:
            drawLine(app.boardLeft + (j+1) * app.boxHeight, app.boardTop, 
                        app.boardLeft + (j+1) * app.boxHeight,
                        app.boardTop + app.boardHeight, 
                        lineWidth = 4 * app.cellBorderWidth)

def play_getCell(app, x, y):
    dx = x - app.boardLeft
    dy = y - app.boardTop
    cellWidth, cellHeight = play_getCellSize(app)
    row = math.floor(dy / cellHeight)
    col = math.floor(dx / cellWidth)
    if (0 <= row < app.rows) and (0 <= col < app.cols):
        return (row, col)
    else:
        return None
        
def play_getCellLeftTop(app, row, col):
    cellWidth, cellHeight = play_getCellSize(app)
    cellLeft = app.boardLeft + col * cellWidth
    cellTop = app.boardTop + row * cellHeight
    return (cellLeft, cellTop)
    
def play_getCellSize(app):
    cellWidth = app.boardWidth / app.cols
    cellHeight = app.boardHeight / app.rows
    return (cellWidth, cellHeight)

def play_loadBoardPaths(filters):
    boardPaths = [ ]
    for filename in os.listdir(f'C://Users/conra/Desktop/15-112_TP/tp-starter-files/tp-starter-files/boards'):
        if filename.endswith('.txt'):
            if play_hasFilters(filename, filters):
                boardPaths.append(f'C://Users/conra/Desktop/15-112_TP/tp-starter-files/tp-starter-files/boards/{filename}')
    return boardPaths

def play_hasFilters(filename, filters=None):
    if filters == None: 
        return True
    for filter in filters:
        if filter not in filename:
            return False
    return True

def play_loadRandomBoard(filters=None):
    boardPathsList = play_loadBoardPaths(filters)
    board = random.choice(boardPathsList)
    return board

##################
#splash screen
##################
def splash_onAppStart(app):
    app.color = 'hotPink'

def splash_redrawAll(app):
    drawRect(0, 0, 400, 400, fill = 'pink')
    drawLine(20, 20, 380, 20, lineWidth = 3, fill = app.color)
    drawLine(40, 40, 360, 40, lineWidth = 3, dashes = True)
    drawLine(20, 20, 20, 380, lineWidth = 3, fill = app.color)
    drawLine(40, 40, 40, 360, lineWidth = 3, dashes = True)
    drawLine(20, 380, 380, 380, lineWidth = 3, fill = app.color)
    drawLine(40, 360, 360, 360, lineWidth = 3, dashes = True)
    drawLine(380, 20, 380, 380, lineWidth = 3, fill = app.color)
    drawLine(360, 40, 360, 360, lineWidth = 3, dashes = True)
    drawCircle(20, 20, 5, fill = app.color)
    drawCircle(380, 20, 5, fill = app.color)
    drawCircle(20, 380, 5, fill = app.color)
    drawCircle(380, 380, 5, fill = app.color)

    drawLabel('Sudoku', 200, 160, bold = True, size = 75, fill = 'black')
    drawLabel('Sudoku', 200, 160, bold = True, size = 67.5, fill = 'hotPink')
    drawLabel('Sudoku', 200, 160, bold = True, size = 60, fill = 'white')
    drawLabel("Let's play", 200, 100, bold = True, size = 30)
    drawLabel("Press 'p' to start playing Sudoku", 200, 230, size = 18, bold = True, fill = 'hotPink')
    drawLabel("Press 'h' for instructions", 200, 260, size = 18, bold = True, fill = 'white')
    drawLabel('HAVE FUN', 200, 310, size = 40, bold = True, fill = 'hotPink')

def splash_onKeyPress(app, key):
    #add direction to splash screen
    if key == 'p':
        play_onScreenStart(app)
        setActiveScreen('play')
    elif key == 'h':
        setActiveScreen('help')
        

#######################
#help screen
#######################
def help_onScreenStart(app):
    app.color = 'lightPink'

def help_onKeyPress(app, key):
    # add to screen
    if key == 'p':
        setActiveScreen('help')

def help_redrawAll(app):
    drawRect(0, 0, 400, 400, fill = app.color)
    drawRect(6, 6, 388, 388, fill = None, border = 'black', borderWidth = 6)
    drawRect(120, 30, 160, 40, fill = 'lightPink')
    drawRect(120, 30, 160, 40, fill = None, border = 'black')
    drawLabel('Instructions', 200, 50, bold = True, size = 20)
    drawLabel("Notice how there exists 3 'regions':", 200, 110, size = 16, bold = True)
    drawLabel(' - 9 rows (horizontal)', 200, 140, size = 16, bold = True)
    drawLabel(' - 9 columns (vertical)', 200, 160, size = 16, bold = True)
    drawLabel(' - 9 regions (denoted by the bolded blocks)', 200, 180, size = 16, bold = True)
    drawLine(65, 120, 335, 120)
    drawLabel('Each region must contain digits 1-9 exactly once', 200, 220, size = 16, bold = True, fill = 'white')  
    drawLabel("Hint: Each cell displays numbers called 'legals'", 200, 250, size = 16, bold = True)
    drawLabel(' * legals are numbers that can occupy that cell', 200, 270, size = 16, bold = True)  
    drawLabel('Use logic to determine which numbers go where!', 200, 300, size = 16, bold = True, fill = 'white')
    drawLabel('GOOD LUCK', 200, 340, size = 20, bold = True)
    drawLabel('HAVE FUN', 200, 360, size = 20, bold = True)

def main():
    runAppWithScreens(initialScreen='splash')
    rowRegion()
    
main()
