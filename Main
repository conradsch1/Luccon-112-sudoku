# project partners: Conrad Schaumburg (cschaumb) and Lucy Blazquez (lblazque)

from cmu_graphics import *
import math
import os
import random
import copy
import itertools

######
#make Allregions list
#####
def createAllRegions(rows, cols):
    rowRegions = createAllRowsRegions(rows, cols)
    colRegions = createAllColRegions(rows, cols)
    blockRegions = createAllBlockRegions(rows)
    return [rowRegions, colRegions, blockRegions]

def createAllRowsRegions(rows, cols):
    rowRegions = []
    for row in range(rows):
        rowList = [(row, col) for col in range(cols)]
        rowRegions.append(rowList)
    return rowRegions

def createAllColRegions(rows, cols):
    colRegions = []
    for col in range(cols):
        colList = [(row, col) for row in range(rows)]
        colRegions.append(colList)
    return colRegions

#used isLegal sedoku code
def createAllBlockRegions(rows):
    blockRegions = []
    numberOfBlocks = rows
    blockSize = pythonRound((rows) ** 0.5)
    for block in range(numberOfBlocks):
        blockList = createBlockList(block, blockSize)
        blockRegions.append(blockList)
    return blockRegions
        
def createBlockList(block, blockSize):
    startingRow = block // blockSize * blockSize
    startingCol = block % blockSize * blockSize
    blockList = []
    for drow in range(blockSize):
        for dcol in range(blockSize):
            (row, col) = startingRow + drow, startingCol + dcol
            blockList.append((row,col))
    return blockList

#global variabe list of All regions [rowRegions, ColRegions, BlockRegions]
regions = createAllRegions(9, 9)

######
######

#make initial legals when make initial board and unchanged legals. Then add make new until have initial board. then clear state list

class State():
    #since I'm making copyies of state classes does init only run on the first. Does it run when I make a copy
    def __init__(self, board, legals):
        self.board = board
        self.legals = legals

    def printBoard(self):
        print2dList(self.board)

    def printLegals(self):
            colWidth = 4
            for col in range(9):
                colWidth = max(colWidth, 1+max([len(self.legals[row][col]) for row in range(9)]))
            for row in range(9):
                for col in range(9):
                    label = ''.join([str(v) for v in sorted(self.legals[row][col])])
                    if label == '': label = '-'
                    print(f"{' '*(colWidth - len(label))}{label}", end='')
                print()

    def print(self): 
        self.printBoard(); self.printLegals()

    @staticmethod
    def getRowRegion(row):
        return regions[0][row]

    @staticmethod
    def getColRegion(col):
        return regions[1][col]

    @staticmethod
    def getBlockRegion(block):
        return regions[2][block]

    @staticmethod
    def getBlock(row, col):
        rows = len(regions[0][0])
        blockSize = pythonRound((rows) ** 0.5)
        return ((row // blockSize)) * blockSize + (col//blockSize)

    @staticmethod
    def getCellRegions(row, col):
        rowRegion = State.getRowRegion(row)
        colRegion = State.getColRegion(col)
        block = State.getBlock(row, col)
        blockRegion = State.getBlockRegion(block)
        return (rowRegion, colRegion, blockRegion)


    #https://www.geeksforgeeks.org/python-remove-discard-sets/ for .discard()
    def banLegals(self, row, col, value):
        # mutates self.legals
        cellRegions = State.getCellRegions(row, col)
        if value != 0: #seting cell to empty doesn't change legas
            self.legals[row][col] = set() #if a cell is filled it should have no legals
            for region in cellRegions:
                for (row, col) in region:
                    self.legals[row][col].discard(value)

    def set(self, row, col, value):
        nextState = copy.deepcopy(self)
        nextState.board[row][col] = value
        nextState.banLegals(row, col, value)
        return nextState
    
    def getHint2(self):
        for regionType in regions:
            for region in regionType:
                for N in range(2, 6):
                    result = self.applyRule2(region, N)
                    if result != None:
                        return result
        return None
    
    def applyRule2(self, region, N):
        for targetCells in itertools.combinations(region, N):
            for targetLegals in itertools.combinations(range(1,10), N):
                if self.valuesAreOnlyLegals(targetCells, targetLegals):
                    return self.getBansForAllRegions(targetCells, targetLegals)
                
    def valuesAreOnlyLegals(self, targetCells, targetLegals):
        targetLegals = set(targetLegals)
        for cell in targetCells:
            (row, col) = cell
            cellLegals = self.legals[row][col]
            setDif = cellLegals - targetLegals
            if setDif == set():
                return True
        return False
    
    def getBansForAllRegions(self, targetCells, targetLegals):
        movesList = []
        for regionType in regions:
            for region in regionType:
                region = set(region)
                targetCells = set(targetCells)
                if targetCells.intersection(region) == targetCells:
                    for cell in region:
                        if cell not in targetCells:
                            for legal in targetLegals:
                                (row, col) = cell
                                move = ('ban', row, col, legal)
                                movesList.append(move)
        return movesList

##################
# play screen
###################

def play_onScreenStart(app):
    app.rows = 9
    app.cols = 9
    app.boardLeft = 50
    app.boardTop = 50
    app.boardWidth = 300
    app.boardHeight = 300
    app.boxWidth = app.boardWidth/app.cols
    app.boxHeight = app.boardHeight/app.rows
    app.currentStateIndex = None
    #app.initialBoard = None
    app.statesList = []
    app.showLegals = False

    app.cellBorderWidth = 1

    app.selection = None
    app.number = None
    #steps for making starterStarte/ first state
    difficulty = app.getTextInput('''What difficulty do you want? Options:
                                     easy, medium, hard, expert, evil''')
    if difficulty == '': 
        difficulty = None
    boardPath = play_loadRandomBoard(difficulty)
    #print(boardPath)
    #for testing
    #boardPath = "C://Users/conra/Desktop/15-112_TP/tp-starter-files/tp-starter-files/boards/easy-01.png.txt"
    readBoard = play_readBoard(boardPath)
    startState = play_makeStarterState(app, readBoard)
    app.statesList.append(startState)
    app.currentStateIndex = 0
    #make global the solution to board. won't ever change, but needs to be acessed by all instances
    global solutionState
    solutionState = getSolution(startState)
    print2dList(solutionState.board)

def getSolution(state):
    zeroCount = getZeroCount(state.board)
    return solver(state, zeroCount)

def solver(state, zeroCount):
    #print(zeroCount)
    if zeroCount == 0:
        return state
    else:
        LeastLegalsCell = getLeastLegalsCell(state.legals)
        if LeastLegalsCell == None:
            return None
        row, col = LeastLegalsCell
        for value in state.legals[row][col]:
            newState = state.set(row,col, value)
            solution = solver(newState, zeroCount - 1)
            if solution != None:
                return solution
            #undo is implict
        return None

def getLeastLegalsCell(legals):
    LeastLegalsCell = None
    smallestLen = 10
    rows, cols = len(legals), len(legals[0])
    for row in range(rows):
        for col in range(cols):
            lenCellLegals = len(legals[row][col])
            if (lenCellLegals > 0) and (lenCellLegals < smallestLen):
                LeastLegalsCell = (row, col)
                smallestLen = lenCellLegals
    return LeastLegalsCell

#copied from Conrad's solve MiniSudoku: https://cs3-112-f22.academy.cs.cmu.edu/exercise/4823
def getZeroCount(board):
    rows, cols = len(board), len(board[0])
    zeroCount = 0
    for row in range(rows):
        for col in range(cols):
            if board[row][col] == 0: zeroCount += 1
    return zeroCount

def play_readFile(path):
    with open(path, "rt") as f:
        return f.read()

def play_makeinitialLegals(app):
    initialLegals = []
    for row in range(app.rows):
        rowList = [set(range(1,10)) for col in range(app.cols)]
        initialLegals.append(rowList)
    return initialLegals
    
def play_drawLegals(app):
    currState = app.statesList[app.currentStateIndex]
    currLegals = currState.legals
    rows, cols = len(currLegals), len(currLegals[0])
    for row in range(rows):
        for col in range(cols):
            currLegalsSet = currLegals[col][row]
            if currLegalsSet != set():
                for num in currLegalsSet:
                    if num == 1:
                        drawLabel('1', 50 + row*33 + 9, 50 + col*33 + 9, size = 13)
                    elif num == 2:
                        drawLabel('2', 50 + row*33 + 18, 50 + col*33 + 9, size = 13)
                    elif num == 3:
                        drawLabel('3', 50 + row*33 + 27, 50 + col*33 + 9, size = 13)
                    elif num == 4:
                        drawLabel('4', 50 + row*33 + 9, 50 + col*33 + 18, size = 13)
                    elif num == 5:
                        drawLabel('5', 50 + row*33 + 18, 50 + col*33 + 18, size = 13)
                    elif num == 6:
                        drawLabel('6', 50 + row*33 + 27, 50 + col*33 + 18, size = 13)
                    elif num == 7:
                        drawLabel('7', 50 + row*33 + 9, 50 + col*33 + 27, size = 13)
                    elif num == 8:
                        drawLabel('8', 50 + row*33 + 18, 50 + col*33 + 27, size = 13)
                    elif num == 9:
                        drawLabel('9', 50 + row*33 + 27, 50 + col*33 + 27, size = 13)

def play_makeEmptyState(app):
    initialBoard = [[None] * app.cols for row in range(app.rows)]
    initialLegals = play_makeinitialLegals(app)
    return State(initialBoard, initialLegals)

def play_readBoard(boardPath):
    contents = play_readFile(boardPath)
    readBoard = []
    for line in contents.splitlines(): 
        rowList = []
        for cellValue in line.split(' '):
            cellValue = int(cellValue)
            rowList.append(cellValue)
        readBoard.append(rowList)
    return readBoard

def play_makeStarterState(app, readBoard):
    initalState = play_makeEmptyState(app)
    currentState = initalState
    for row in range(app.rows):
        for col in range(app.cols):
            value = readBoard[row][col]
            nextState = currentState.set(row, col, value)
            currentState = nextState
    return currentState
    
def play_getNakedSingle(legals):
    rows, cols = len(legals), len(legals[0])
    for row in range(rows):
        for col in range(cols):
            cellLegalsLen = len(legals[row][col])
            if cellLegalsLen == 1:
                return row, col

def play_onMousePress(app, mouseX, mouseY):
    app.selection = None
    cell = play_getCell(app, mouseX, mouseY)
    if cell != None:
        row, col = cell #why this line
        app.number = cell
            
def play_onMouseMove(app, mouseX, mouseY):
    selectedCell = play_getCell(app, mouseX, mouseY)
    if selectedCell == None:
        app.selection = None
    else:
        app.selection = selectedCell
    
def play_onKeyPress(app, key):
    if app.number != None:
        row, col = app.number
        if key.isdigit() and key != '0':
            value = int(key)
            app.statesList = app.statesList[:app.currentStateIndex+1] #remove all the redo boards
            currentState = app.statesList[app.currentStateIndex]
            newState = currentState.set(row, col, value)
            app.statesList.append(newState)
            app.currentStateIndex += 1

    if key == 'l':
        app.showLegals = not app.showLegals

    if key == 'u':
        app.currentStateIndex -= 1
        if app.currentStateIndex < 0:
            app.currentStateIndex = 0
    elif key == 'r':
        app.currentStateIndex += 1
        if app.currentStateIndex >= len(app.statesList):
            app.currentStateIndex = len(app.statesList) - 1

    elif key == 'q':
        # weak hint 1
        currentState = app.statesList[app.currentStateIndex]
        targetCell = play_getNakedSingle(currentState.legals)
        #consider the case that targetCell = NOne
        #DO highlight of targetCell
    elif key == 'Q':
        #strong hint 1
        currentState = app.statesList[app.currentStateIndex]
        targetCell = play_getNakedSingle(currentState.legals)
        if targetCell != None:
            row, col = targetCell
            value = currentState.legals[row][col].pop()
            newState = currentState.set(row, col, value)
            app.statesList.append(newState)
            app.currentStateIndex += 1
    elif key == 'w':
        #weak hint 2
        currentState = app.statesList[app.currentStateIndex]
        moves = currentState.getHint2()
        print(moves)
        #high light based on row and col of moves

    elif key == 'W':
        #Strong hint 2
        currentState = app.statesList[app.currentStateIndex]
        moves = currentState.getHint2()
        print(moves)
        for move in moves:
            row = move[1]
            col = move[2]
            value = move[3]
            currentState.banLegals(row, col, value)

    elif key == 'h':
        setActiveScreen('help')
    elif key == 's':
        setActiveScreen('splash')
            
def play_redrawAll(app):
    play_drawBoard(app)
    play_drawBoardBorder(app)
    play_drawLines(app)
    if app.showLegals == True:
        play_drawLegals(app)
    
def play_drawBoard(app):
    for row in range(app.rows):
        for col in range(app.cols):
            play_drawCell(app, row, col)
            board = app.statesList[app.currentStateIndex].board
            if board[row][col] != 0:
                drawLabel(board[row][col], 
                            app.boardLeft + (app.boxWidth*col)+app.boxWidth/2, 
                            app.boardTop + (app.boxHeight*row)+app.boxHeight/2,
                                size = 16)
                solutionBoard = solutionState.board
                if board[row][col] != solutionBoard[row][col]:
                    print(type(board[row][col]))
                    print(type(solutionBoard[row][col]))
                    drawCircle(app.boardLeft + (app.boxWidth*col)+app.boxWidth/4, 
                               app.boardTop + (app.boxHeight*row)+app.boxHeight/4,
                               5, fill = 'green')
            
def play_drawBoardBorder(app):
    drawRect(app.boardLeft, app.boardTop, app.boardWidth, app.boardHeight,
            fill = None, border = 'black', 
            borderWidth = 4 * app.cellBorderWidth)
            
def play_drawCell(app, row, col):
    cellLeft, cellTop = play_getCellLeftTop(app, row, col)
    cellWidth, cellHeight = play_getCellSize(app)
    startBoard = app.statesList[0].board
    if startBoard[row][col] != 0:
        color = 'mistyRose'
    else:
        color = None
    if (row, col) == app.selection:
        color = 'pink'
    elif (row, col) == app.number:
        color = 'red'
    
    drawRect(cellLeft, cellTop, cellWidth, cellHeight,
            fill = color, border = 'black',
            borderWidth = app.cellBorderWidth)
            
def play_drawLines(app):
    #draw horizontal lines
    for i in range(app.rows):
        if (i+1) % 3 == 0 and i != 8:
            drawLine(app.boardLeft, app.boardTop + (i+1) * app.boxWidth, 
                        app.boardLeft + app.boardWidth,
                        app.boardTop + (i+1) * app.boxWidth,
                        lineWidth = 4 * app.cellBorderWidth)
    #draw vertical lines
    for j in range(app.cols):
        if (j+1) % 3 == 0 and j != 8:
            drawLine(app.boardLeft + (j+1) * app.boxHeight, app.boardTop, 
                        app.boardLeft + (j+1) * app.boxHeight,
                        app.boardTop + app.boardHeight, 
                        lineWidth = 4 * app.cellBorderWidth)

def play_getCell(app, x, y):
    dx = x - app.boardLeft
    dy = y - app.boardTop
    cellWidth, cellHeight = play_getCellSize(app)
    row = math.floor(dy / cellHeight)
    col = math.floor(dx / cellWidth)
    if (0 <= row < app.rows) and (0 <= col < app.cols):
        return (row, col)
    else:
        return None
        
def play_getCellLeftTop(app, row, col):
    cellWidth, cellHeight = play_getCellSize(app)
    cellLeft = app.boardLeft + col * cellWidth
    cellTop = app.boardTop + row * cellHeight
    return (cellLeft, cellTop)
    
def play_getCellSize(app):
    cellWidth = app.boardWidth / app.cols
    cellHeight = app.boardHeight / app.rows
    return (cellWidth, cellHeight)

def play_loadBoardPaths(filters):
    boardPaths = [ ]
    for filename in os.listdir(f'C://Users/conra/Desktop/15-112_TP/tp-starter-files/tp-starter-files/boards'):
        if filename.endswith('.txt'):
            if play_hasFilters(filename, filters):
                boardPaths.append(f'C://Users/conra/Desktop/15-112_TP/tp-starter-files/tp-starter-files/boards/{filename}')
    return boardPaths

def play_hasFilters(filename, filters=None):
    if filters == None: 
        return True
    for filter in filters:
        if filter not in filename:
            return False
    return True

def play_loadRandomBoard(filters=None):
    boardPathsList = play_loadBoardPaths(filters)
    board = random.choice(boardPathsList)
    return board

##################
#splash screen
##################
def splash_onAppStart(app):
    app.color = 'hotPink'

def splash_redrawAll(app):
    drawRect(0, 0, 400, 400, fill = 'pink')
    drawLine(20, 20, 380, 20, lineWidth = 3, fill = app.color)
    drawLine(40, 40, 360, 40, lineWidth = 3, dashes = True)
    drawLine(20, 20, 20, 380, lineWidth = 3, fill = app.color)
    drawLine(40, 40, 40, 360, lineWidth = 3, dashes = True)
    drawLine(20, 380, 380, 380, lineWidth = 3, fill = app.color)
    drawLine(40, 360, 360, 360, lineWidth = 3, dashes = True)
    drawLine(380, 20, 380, 380, lineWidth = 3, fill = app.color)
    drawLine(360, 40, 360, 360, lineWidth = 3, dashes = True)
    drawCircle(20, 20, 5, fill = app.color)
    drawCircle(380, 20, 5, fill = app.color)
    drawCircle(20, 380, 5, fill = app.color)
    drawCircle(380, 380, 5, fill = app.color)

    drawLabel('Sudoku', 200, 160, bold = True, size = 75, fill = 'black')
    drawLabel('Sudoku', 200, 160, bold = True, size = 67.5, fill = 'hotPink')
    drawLabel('Sudoku', 200, 160, bold = True, size = 60, fill = 'white')
    drawLabel("Let's play", 200, 100, bold = True, size = 30)
    drawLabel("Press 'p' to start playing Sudoku", 200, 230, size = 18, bold = True, fill = 'hotPink')
    drawLabel("Press 'h' for instructions", 200, 260, size = 18, bold = True, fill = 'white')
    drawLabel('HAVE FUN', 200, 310, size = 40, bold = True, fill = 'hotPink')

def splash_onKeyPress(app, key):
    #add direction to splash screen
    if key == 'p':
        play_onScreenStart(app)
        setActiveScreen('play')
    elif key == 'h':
        setActiveScreen('help')
        

#######################
#help screen
#######################
def help_onScreenStart(app):
    app.color = 'lightPink'

def help_onKeyPress(app, key):
    # add to screen
    if key == 'p':
        setActiveScreen('help')

def help_redrawAll(app):
    drawRect(0, 0, 400, 400, fill = app.color)
    drawRect(6, 6, 388, 388, fill = None, border = 'black', borderWidth = 6)
    drawRect(120, 30, 160, 40, fill = 'lightPink')
    drawRect(120, 30, 160, 40, fill = None, border = 'black')
    drawLabel('Instructions', 200, 50, bold = True, size = 20)
    drawLabel("Notice how there exists 3 'regions':", 200, 110, size = 16, bold = True)
    drawLabel(' - 9 rows (horizontal)', 200, 140, size = 16, bold = True)
    drawLabel(' - 9 columns (vertical)', 200, 160, size = 16, bold = True)
    drawLabel(' - 9 regions (denoted by the bolded blocks)', 200, 180, size = 16, bold = True)
    drawLine(65, 120, 335, 120)
    drawLabel('Each region must contain digits 1-9 exactly once', 200, 220, size = 16, bold = True, fill = 'white')  
    drawLabel("Hint: Each cell displays numbers called 'legals'", 200, 250, size = 16, bold = True)
    drawLabel(' * legals are numbers that can occupy that cell', 200, 270, size = 16, bold = True)  
    drawLabel('Use logic to determine which numbers go where!', 200, 300, size = 16, bold = True, fill = 'white')
    drawLabel('GOOD LUCK', 200, 340, size = 20, bold = True)
    drawLabel('HAVE FUN', 200, 360, size = 20, bold = True)

##debug printing
def repr2dList(L):
    if (L == []): return '[]'
    output = [ ]
    rows = len(L)
    cols = max([len(L[row]) for row in range(rows)])
    M = [['']*cols for row in range(rows)]
    for row in range(rows):
        for col in range(len(L[row])):
            M[row][col] = repr(L[row][col])
    colWidths = [0] * cols
    for col in range(cols):
        colWidths[col] = max([len(M[row][col]) for row in range(rows)])
    output.append('[\n')
    for row in range(rows):
        output.append(' [ ')
        for col in range(cols):
            if (col > 0):
                output.append(', ' if col < len(L[row]) else '  ')
            output.append(M[row][col].rjust(colWidths[col]))
        output.append((' ],' if row < rows-1 else ' ]') + '\n')
    output.append(']')
    return ''.join(output)

def print2dList(L):
    print(repr2dList(L))

def main():
    runAppWithScreens(initialScreen='splash', width=600, height=600)
    
main()
